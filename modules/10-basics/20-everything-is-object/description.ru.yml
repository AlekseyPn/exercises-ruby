---

name: Все есть объект
theory: |

  Руби по своим возможностям и подходам в разработке близок к JavaScript и Python, но имеет свои особенности. Разработчики языка во многом опирались на Smalltalk, Lisp (это семейство языков), Perl и другие подобные языки. Это привело к интересному результату. Во-первых руби **очень** объектно-ориентированный язык. В руби все есть объект включая `nil` (это аналог `null`) и каждая операция это вызов метода:

  ```ruby
  1.positive? # true
  1.zero? # null
  nil.to_i # 0
  # проверяем что у объекта есть метод to_s
  true.respond_to?(:to_s) # true
  1 + 1 # на самом деле 1.+(1)
  ```

  Одна из сильных сторон руби – [стандартная библиотека](https://ruby-doc.org/). Она решает практически все возникающие задачи. В одних только строках 185 встроенных методов!

  *Это одна из причин, почему руби чаще других выигрывает в [CodeBattle](https://codebattle.hexlet.io/)*

  ```ruby
  # Количество методов у разных типов данных
  # В примерах ниже вызывается метод methods,
  # хотя кажется что это обращение к свойству
  ''.methods.count # 185
  1.methods.count # 145
  [].methods.count # 191
  ```

  В руби все кроме присваивания это вызовы методов. Такой подход позволяет переопределять буквально любое поведение:

  ```ruby
  # То что на самом деле происходит когда мы выполняем "операции"
  1.+(4) # 6
  1.>(3) # false
  ```

  На этом основано очень много кода, особенно библиотечного. Например у любого объекта можно определить синтаксис аналогичный доступу к массиву `[]`. Или можно определить операции для дат, сделав работу с ними максимально простой (как в примере прошлого урока). А вот как выглядят сеттеры у объектов:

  ```ruby
  # Кажется что это прямое изменение свойства
  # На самом деле это сеттер
  obj.key = 'value'
  ```

  В руби, в отличии от большинства других языков, принято использовать предикаты практически для всех часто встречающихся проверок. Например как мы обычно проверяем что число равно нулю? С помощью сравнения с нулем. В руби это тоже работает, но это не ruby way:

  ```ruby
  0.zero? # true
  1.zero? # false
  2.positive? # true

  # четное/не четное
  8.even? # true
  8.odd? # false

  ''.empty? # true
  'wow'.empty? # false

  # не пустой массив
  items.any?
  # пустой массив
  items.empty?
  ```

  Все данные в руби это объекты, или как говорят, инстансы классов. Для каждого типа у руби свой класс. `nil` например представлен классом `NilClass` и является единственным его объектом. `true` объект класса `TrueClass`, а `false` объект класса `FalseClass`.

  Узнать класс любого объекта можно так:

  ```ruby
  1.class # Integer
  ''.class # String
  nil.class # NilClass
  ```

  С другой стороны классы в руби тоже объекты, у которых есть свои классы 0_o. Но это уже совсем другая история) Есть даже такая шутка (но это не шутка): в руби объект это класс, а класс это объект. Почему это так – узнаем чуть позже.

instructions: |

  Напечатайте на экран следующий вызов:

  ```ruby
  # Здесь выводятся на экран все методы строк,
  # которые содержат знак вопроса в имени
  # Фактически это вывод списка предикатов
  # Тоже самое можно сделать для любого типа
  puts 'hexlet'.methods.grep(/\?/)
  # Будет выведено около 20 имен
  ```

tips: []
